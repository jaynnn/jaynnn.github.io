---
layout: post
title: 关于 celling 的设计与实现
date: 2024-08-18 21:22
description: About Celling.
tags: rust bevy marching-squares earcut game-of-life
categories: tech
---

## 目录
- [目录](#目录)
- [前言](#前言)
- [前置内容简介（理解项目必需）](#前置内容简介理解项目必需)
- [实现 （源码(https://github.com/jaynnn/celling)）](#实现-源码httpsgithubcomjaynnncelling)
- [只是个半成品，有许多的问题还没得到解决。](#只是个半成品有许多的问题还没得到解决)


## 前言

## 前置内容简介（理解项目必需）
1. noita
   1. noita是一个2d像素游戏，其核心驱动是一个特殊实现的物理引擎falling everything，这个引擎启发自生命细胞和落沙模拟，celling的大多实现都借鉴自它，可惜它并不开源。关于noita还有许多令人惊叹的设计，比如抽卡式的可编程的连锁法、复杂的怪物AI行为、随机但不失难度梯度的超大世界地图生成、有趣的谜题与彩蛋等，这是我最喜欢的游戏之一，安利一下。
2. 生命细胞与落沙模拟
   1. 生命细胞源于康威的“生命游戏”，其核心就是给定一个简单的演化规则，对于每个细胞的初始状态，能够有持续的演化状态，定好规则与初始状态能够得到一些有趣的演变模式。
   2. 落沙模拟本质上是一些物理粒子在基本的物理规则下的运动。在celling中，是以像素艺术的像素块为模拟单元，用生命细胞的变形做实现。比如说沙子，制定的规则就是：依次检查下方-左下-右下是否可以落下；又比如水，就是检查下方-左下-右下-左-右是否可以移动。依次类推，根据周围粒子的状态，就可以确定本粒子当前的状态。
3. bevy与ecs
   1. bevy 是rust写的一个基于webgpu、ecs驱动的现代游戏引擎。
   2. ecs是比较现代的一种设计模式，非常适用于游戏。ecs分别是 entity、component、system，entity是实体，实现为一个唯一标识符，唯一标识着游戏中的每个对象，比如玩家、子弹等。component是组件，是实际存放数据的地方，组件会附加在实体身上，从而赋予实体具体的属性，比如说玩家（血量、位置、速度、精灵表等），子弹（位置、速度等）。system是系统，包含了实体的逻辑部分，系统通过查询的方式获取所有包含特定组件的实体，然后对他们进行更新。
   3. rust与ecs的交融，天然屏蔽了并行计算带来的复杂性，这是bevy的优势。
4. marching squares与earcut
   1. 这两个算法是用来实现刚体的。
   2. marching squares是一种轮廓生成算法，通过设定每个像素块的每个顶点的值，根据一个参数值取差值之后剩下的大于0的顶点（一共有16种状态），生成连起来的轮廓。
   3. earcut是一种将多边形拆分成多个三角形的算法。
   4. 对于世界中演化的像素块，我们始终知道每个像素块的定义值，就可以根据以上两个算法生成许多的三角块，然后塞进比如另外一个物理引擎，比如bevy的bevy_rapier库的根据多个三角形顶点生成刚体的接口，就可以动态地生成可碰撞的实体了。


## 实现 （源码(https://github.com/jaynnn/celling)）
1. 黑白棋盘并行化与像素粒子并行化的抉择。


## 只是个半成品，有许多的问题还没得到解决。
1. 刚体破坏
2. 像素块的遍历顺序问题