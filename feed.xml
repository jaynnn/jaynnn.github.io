<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn, en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jaynnn.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jaynnn.github.io/" rel="alternate" type="text/html" hreflang="cn, en"/><updated>2025-05-15T06:36:51+00:00</updated><id>https://jaynnn.github.io/feed.xml</id><title type="html">JaynAlpha</title><subtitle>enum JaynAlphaBlog{Rust, IndieGameDev, bevy} </subtitle><entry><title type="html">关于 celling 的设计与实现</title><link href="https://jaynnn.github.io/blog/2024/about-celling/" rel="alternate" type="text/html" title="关于 celling 的设计与实现"/><published>2024-08-18T21:22:00+00:00</published><updated>2024-08-18T21:22:00+00:00</updated><id>https://jaynnn.github.io/blog/2024/about-celling</id><content type="html" xml:base="https://jaynnn.github.io/blog/2024/about-celling/"><![CDATA[<h2 id="目录">目录</h2> <ul> <li><a href="#目录">目录</a></li> <li><a href="#前言">前言</a></li> <li><a href="#前置内容简介理解项目必需">前置内容简介（理解项目必需）</a></li> <li><a href="#实现">实现</a></li> <li><a href="#只是个半成品有许多的问题还没得到解决">只是个半成品，有许多的问题还没得到解决。</a></li> </ul> <h2 id="前言">前言</h2> <h2 id="前置内容简介理解项目必需">前置内容简介（理解项目必需）</h2> <ol> <li>noita <ol> <li>noita是一个2d像素游戏，其核心驱动是一个特殊实现的物理引擎falling everything，这个引擎启发自生命细胞和落沙模拟，celling的大多实现都借鉴自它，可惜它并不开源。关于noita还有许多令人惊叹的设计，比如抽卡式的可编程的连锁法、复杂的怪物AI行为、随机但不失难度梯度的超大世界地图生成、有趣的谜题与彩蛋等，这是我最喜欢的游戏之一，安利一下。</li> </ol> </li> <li>生命细胞与落沙模拟 <ol> <li>生命细胞源于康威的“生命游戏”，其核心就是给定一个简单的演化规则，对于每个细胞的初始状态，能够有持续的演化状态，定好规则与初始状态能够得到一些有趣的演变模式。</li> <li>落沙模拟本质上是一些物理粒子在基本的物理规则下的运动。在celling中，是以像素艺术的像素块为模拟单元，用生命细胞的变形做实现。比如说沙子，制定的规则就是：依次检查下方-左下-右下是否可以落下；又比如水，就是检查下方-左下-右下-左-右是否可以移动。依次类推，根据周围粒子的状态，就可以确定本粒子当前的状态。</li> </ol> </li> <li>bevy与ecs <ol> <li>bevy 是rust写的一个基于webgpu、ecs驱动的现代游戏引擎。</li> <li>ecs是比较现代的一种设计模式，非常适用于游戏。ecs分别是 entity、component、system，entity是实体，实现为一个唯一标识符，唯一标识着游戏中的每个对象，比如玩家、子弹等。component是组件，是实际存放数据的地方，组件会附加在实体身上，从而赋予实体具体的属性，比如说玩家（血量、位置、速度、精灵表等），子弹（位置、速度等）。system是系统，包含了实体的逻辑部分，系统通过查询的方式获取所有包含特定组件的实体，然后对他们进行更新。</li> <li>rust与ecs的交融，天然屏蔽了并行计算带来的复杂性，这是bevy的优势。</li> </ol> </li> <li>marching squares与earcut <ol> <li>这两个算法是用来实现刚体的。</li> <li>marching squares是一种轮廓生成算法，通过设定每个像素块的每个顶点的值，根据一个参数值取差值之后剩下的大于0的顶点（一共有16种状态），生成连起来的轮廓。</li> <li>earcut是一种将多边形拆分成多个三角形的算法。</li> <li>对于世界中演化的像素块，我们始终知道每个像素块的定义值，就可以根据以上两个算法生成许多的三角块，然后塞进比如另外一个物理引擎，比如bevy的bevy_rapier库的根据多个三角形顶点生成刚体的接口，就可以动态地生成可碰撞的实体了。</li> </ol> </li> </ol> <h2 id="实现">实现</h2> <ol> <li><a href="https://github.com/jaynnn/celling">源码</a></li> <li>基础的像素物理演化，如（沙、水、气体）</li> <li>黑白棋盘并行化与像素粒子并行化的抉择。</li> <li>动态刚体生成</li> </ol> <h2 id="只是个半成品有许多的问题还没得到解决">只是个半成品，有许多的问题还没得到解决。</h2> <ol> <li>刚体破坏</li> <li>像素块的遍历顺序问题</li> </ol>]]></content><author><name></name></author><category term="tech"/><category term="rust"/><category term="bevy"/><category term="marching-squares"/><category term="earcut"/><category term="game-of-life"/><summary type="html"><![CDATA[About Celling.]]></summary></entry><entry><title type="html">redis sorted set 原理</title><link href="https://jaynnn.github.io/blog/2024/redis-sorted_set_implement/" rel="alternate" type="text/html" title="redis sorted set 原理"/><published>2024-07-10T20:33:00+00:00</published><updated>2024-07-10T20:33:00+00:00</updated><id>https://jaynnn.github.io/blog/2024/redis-sorted_set_implement</id><content type="html" xml:base="https://jaynnn.github.io/blog/2024/redis-sorted_set_implement/"><![CDATA[<h2 id="目录">目录</h2> <ol> <li><a href="#前言">前言</a></li> <li><a href="#ziplist&amp;listpack">ziplist &amp;&amp; listpack</a> <ol> <li><a href="#ziplist">ziplist</a></li> <li><a href="#listpack">listpack</a></li> </ol> </li> <li><a href="#skiplist&amp;hash">skiplist+hash</a></li> <li><a href="#参考">参考</a></li> </ol> <h2 id="前言">前言</h2> <ul> <li>在数据元素较少的情况下，redis采用了ziplist(版本7.0之前)和listpack(版本7.0之前)的方式，这种方式相比普通的双向链表，能够保证内存更加有序(内存碎片减少)且节省(每个元素少存了指向前后节点的指针)。在数据元素较多的情况下，采用跳跃表加哈希表的方式。</li> </ul> <h2 id="ziplistlistpack">ziplist&amp;listpack</h2> <h4 id="ziplist">ziplist</h4> <ol> <li>ziplist 就是一种空间紧凑的双向队列。</li> </ol> <p>优势：</p> <ol> <li>内存利用率极高，在双端插入有O(1)的性能，在中间插入和查找有O(n)的性能，别看仅是O(n)，由于内存的连续，充分利用了CPU缓存，在小规模数据中有非常好的性能优势。</li> </ol> <p>缺点：</p> <ol> <li>在于每次插入、删除操作都需要对内存进行调整，性能与内存用量相关。</li> <li>由于每个元素都会保存上一个元素的长度，且这个长度本身占用的内存是会发生变化的，当一个元素的长度发生变化，可能会导致后续的节点长度发生变化，从而引发级联更新(就是对元素A的操作引发了其他元素的变化)。</li> </ol> <p>源码中对ziplist的解释：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> The ziplist is a specially encoded dually linked list that is designed to
  be very memory efficient. It stores both strings and integer values,
  where integers are encoded as actual integers instead of a series of
  characters. It allows push and pop operations on either side of the list
   in O(1) time. However, because every operation requires a reallocation
   of the memory used by the ziplist, the actual complexity is related to
   the amount of memory used by the ziplist.

 ** 翻译 **：
 ziplist是一种特殊编码的双链表，它是为了高内存效率而设计的。它存储字符串和整数
 值，其中整数被编码为实际整数而不是一系列字符。它允许在列表的两侧进行在 O(1) 时间
 复杂度的推入和弹出操作。然而，由于每次操作都需要重新分配ziplist使用的内存，实际
 复杂度与ziplist使用的内存量相关。
</code></pre></div></div> <ol> <li>内存布局</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ziplist
&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;

entry
&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;
</code></pre></div></div> <p>zlbytes 存储了整个表的内存占用，包含了其本身占用的四个字节。这个字段可以用来避免遍历从而重新调整整个结构的大小。<br/> zltail 存储了最后一个元素的偏移量，用来弹出最后一个元素而避免遍历。<br/> zllen 存储了元素的数量，注意这个字段只有两个字节大小，也就是超过2^16-2个元素个数时，该值会设置成2^16-1并且从此获取该值需要遍历所有元素。（这也是ziplist不适合数据元素较多的情形的原因之一。）<br/> zlend 是特殊的元素，代表着元素列表的末尾。<br/> entry 由三部分组成。 prevlen 代表着前一个元素的长度，用来从后向前遍历。encoding 存储着元素的类型。entry-data 存储着具体的元素数据（对于小整数可能会没有这个部分）。</p> <ul> <li>对于 prevlen 还要分两种情况，当 prevlen &lt; 254, 则用一个字节来表示；如果 prevlen &gt;= 254 则用 0xFE+四个字节 来表示。</li> <li>对于 encoding 源码中的图示很清晰，这里借用一下：</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|00pppppp| - 1 byte
    字符串类型，长度 &lt;= 63 字节（6位）。
|01pppppp|qqqqqqqq| - 2 bytes
    字符串类型，长度 &lt;= 16383 字节（14位）。
    IMPORTANT: The 14 bit number is stored in big endian.
|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
    字符串类型，长度 &gt;= 16384 字节（32位，第一个字节的多余位数不再使用）。
    IMPORTANT: The 32 bit number is stored in big endian.
|11000000| - 3 bytes
    整型，存储 int16_t (2 bytes)
|11010000| - 5 bytes
    整型，存储 int32_t (4 bytes)
|11100000| - 9 bytes
    整型，存储 int64_t (8 bytes)
|11110000| - 4 bytes
    整型，存储 24位无符号数 (3 bytes)
|11111110| - 2 bytes
    整型，存储 8位无符号数(1 byte)
|1111xxxx| - (xxxx 从 0001 到 1101) 四位整数，只能存 1~13，因为0000和1111已经被占用了。所以具体的数值需要忽略1111的情况下再减去1，比如十六进制 F1, 则代表的数位 1-1=0
|11111111| - 上文提到的 zlend.
注意：所有的整数都是以小端序存储。
</code></pre></div></div> <p>具体的例子（不得不赞叹一下redis的文档实在详尽）：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>以下是存储了两个数字 2 和 5 的例子，总共占用了15个字节：
[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]
      |             |          |       |       |     |
   zlbytes        zltail     zllen    "2"     "5"   end
可以看出，小端序下，[0f 00 00 00] 代表整个结构占用15个字节；[0c 00 00 00]代表第12个字节是最后一个元素，即"5"，；[02 00]代表元素数量为2；[00 f3]中，00代表前一个元素的长度，由于没有则为0，f3表示为|1111xxxx|，则3-1=2，存储的是整数2；[02 f6]的02代表前一个元素占用为2个字节，存储数位6-1=5；[ff]总是代表着结构的末尾。

另外一个entry例子：
[02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]
可以看出，前一个元素长度为2个字节，匹配的是|00pppppp|模式，即长度为11的字符串"Hello World"。
</code></pre></div></div> <h4 id="listpack">listpack</h4> <ol> <li>listpack 主要解决了 ziplist 中的级联更新的问题。</li> <li>内存布局 与 ziplist 差不多，主要区别在于 entry 的结构不同，不在存储上一个元素的大小，而是存储本元素的大小（注意entry-length一定是在空间布局的最后）。</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;encoding&gt; &lt;entry-data&gt; &lt;entry-length&gt;
对于 encoding
|0ppppppp| - 1 byte
    整型，0~127 （7位）。
|10pppppp| - 1 byte
    字符串类型，长度 0~63， entry-data存储字符串内容
|110ppppp|qqqqqqqq| - 2byte
    整型，-4096~4095
|1110pppp|qqqqqqqq| - 2byte
    字符串，长度 0~4095，entry-data存储字符串内容
1111|0000 &lt;4 bytes len&gt; &lt;large string&gt;，即32位长度字符串，后4字节为字符串长度，再之后为字符串内容
1111|0001 &lt;16 bits signed integer&gt;，即16位整型，后2字节为数据
1111|0010 &lt;24 bits signed integer&gt;，即24位整型，后3字节为数据
1111|0011 &lt;32 bits signed integer&gt;，即32位整型，后4字节为数据
1111|0100 &lt;64 bits signed integer&gt;，即64位整型，后8字节为数据
1111|0101 to 1111|1110 are currently not used.   当前不用编码
1111|1111 End of listpack，结尾标识
</code></pre></div></div> <ol> <li>既然移除了 prevlen 那么如何做到从后往前遍历呢？<br/> 这是因为 listpack 特殊设计了 entry-length 结构，它的每个字节的第一位代表了是否为 entry-length 所占用空间的头部，当它需要从后往前遍历时，逐个字节往前找，如果第一位为0，说明已经到头了，当前搜寻的字节拼起来就是前一个元素的大小。</li> </ol> <p>以下是源码：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Decode the backlen and returns it. If the encoding looks invalid (more than
 * 5 bytes are used), UINT64_MAX is returned to report the problem. */
static inline uint64_t lpDecodeBacklen(unsigned char *p) {
    uint64_t val = 0;
    uint64_t shift = 0;
    do {
        val |= (uint64_t)(p[0] &amp; 127) &lt;&lt; shift;
        if (!(p[0] &amp; 128)) break;
        shift += 7;
        p--;
        if (shift &gt; 28) return UINT64_MAX;
    } while(1);
    return val;
}
</code></pre></div></div> <h2 id="skiplisthash">skiplist&amp;hash</h2> <ol> <li> <p>当元素数量超过设定的阈值（max-listpack-entries/max-ziplist-entries）时，则使用跳表加哈希表的方式实现。跳表用来实现快速的插入、删除操作，而哈希表用来是先O(1)级别的查询操作。</p> <ol> <li>跳表的实现可以用做地铁来表示，假设有地铁站A-B-C-D-E，那么假如我要去C，普通的做法是A-B-C，就是遍历找到。那么架设线路是多层设计的： A — E A — C — E A - B - C - D - E 那么就可以从A-E，发现坐过头了，再回到A-C，马上就找到了。在数据规模越大的情况下，这个查询优化越明显。另外，如果需要固定多少个节点就设置一层快捷车道，意味着如果新增元素就需要对原先的层级进行重新排布，这显然不够高效。所以redis的做法是让层数的搭建随机化，最高层数为32层，越高的层数随机到的概率越低，以对数递减的方式（第一层为100%，第二层位50%）。</li> </ol> <p><img src="https://p2-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/28/16f4ce73b1bf06e4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="示例"/></p> <ol> <li>哈希表是对跳表的查询效率进行优化，使之能达到O(1)的查询效率。</li> </ol> </li> </ol> <h2 id="参考">参考</h2> <p>[1] https://github.com/redis/redis<br/> [2] https://juejin.cn/post/7093530299866284045<br/> [3] https://juejin.cn/post/6844904033589657607</p>]]></content><author><name></name></author><category term="tech"/><category term="redis"/><category term="computer-science"/><category term="algorithm"/><summary type="html"><![CDATA[The implement of redis sorted set.]]></summary></entry><entry><title type="html">tcp的两点问题</title><link href="https://jaynnn.github.io/blog/2020/two-question-about-tcp/" rel="alternate" type="text/html" title="tcp的两点问题"/><published>2020-05-30T22:09:00+00:00</published><updated>2020-05-30T22:09:00+00:00</updated><id>https://jaynnn.github.io/blog/2020/two-question-about-tcp</id><content type="html" xml:base="https://jaynnn.github.io/blog/2020/two-question-about-tcp/"><![CDATA[<ol> <li>为什么是三次握手，而不是两次、四次？<br/> 要确保信息传输的完整性，我们需要保证数据具有同步性，tcp连接做的设计是保持初始序列号的同步，即A-&gt;B发送seq=j，B回复seq=j+1，这时候A就可以确定B已经同步了自己的序列号了；同理，B-&gt;A发送seq=k, A回复seq=k+1，这是双方就都确定信息已经同步。<br/> 那么问题就很清晰了，为什么不是四次？即</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. A(j)-&gt;B
    2. B(j+1)-&gt;A
    3. B(k)-&gt;A
    4. A(k+1)-&gt;B
</code></pre></div></div> <p>很明显，[2]、[3]可以合成一步，多余的事情不必做。为什么不是两次？即</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. A(j) -&gt; B
    2. B(j+1 &amp; k) -&gt; A
</code></pre></div></div> <p>也很明显，B并不能确定A同步了自己的序列号。如果[2]在网络上丢失了，这时候就信誓旦旦建立连接，A可以确定B收到了自己的数据，但B并不能确定数据是否正确到达A。</p> <ol> <li>time_wait的作用<br/> time_wait是在主动关闭的一端接收到fin之后进入的状态，为什么需要这个状态呢？原因有两点。</li> </ol> <ul> <li>确保客户端的最终ACK能到达服务器。客户端在收到fin不维护状态信息，则会发送一个错误信息，然后被服务器认定为错误（喂你怎么不转状态，一点反应都没有，是不是崩了），那么服务器就没办法判定这个客户端是否已经关闭了连接（相当于上个问题的[4]没有确认），这时候客户端就需要重传ACK了，若没有TIME_WAIT阶段，客户端已经关闭了，那还怎么重传？</li> <li>保证新建立的连接收到的数据包都是新的。首先了解一个假设（事实）：MSL(最大分节生命期)，即数据包在网络上的存活时间不会不会超过MSL秒。当一个连接建立后，可能会发生重传的现象，即有些数据包在网络上乱串没有到达最终主机，但重发的数据包已经到达了目的主机且手都挥完。在最极限的状态下，乱串数据包还有MSL时间到达目的主机，乱串数据包的回包也有MSL时间回到源主机。这时候如果没有等待阶段，直接新建立了一个完全相同的ip和端口组的连接，旧数据包就会影响新连接的数据。因此需要一个TIME_WAIT阶段，且具有2MSL的时间让时间抹去数据的痕迹，让他们不会影响到新的连接。</li> </ul> <hr/> <ol> <li>为什么需要四次挥手？(2024/0618)<br/> 因为服务端需要先告知客户端自己收到了断开连接的请求，而自己的主动断开需要等到应用层完成断开连接所需要的操作之后再发出。也就是中间的两次信息传输无法合并了。</li> </ol>]]></content><author><name></name></author><category term="tech"/><category term="tcp"/><category term="computer-science"/><summary type="html"><![CDATA[two question about tcp.]]></summary></entry><entry><title type="html">从问题出发考虑TCP的设计原理</title><link href="https://jaynnn.github.io/blog/2020/tcp-design/" rel="alternate" type="text/html" title="从问题出发考虑TCP的设计原理"/><published>2020-05-30T22:09:00+00:00</published><updated>2020-05-30T22:09:00+00:00</updated><id>https://jaynnn.github.io/blog/2020/tcp-design</id><content type="html" xml:base="https://jaynnn.github.io/blog/2020/tcp-design/"><![CDATA[<ol> <li>信息通信里，不可避免信息量会<strong>有损</strong>，如何解决这个问题，保证信息传输是完整而正确的？</li> </ol> <ul> <li>第一种方式是<strong>差错校验码</strong>，通过添加冗余的比特，以恢复真实信息。</li> <li>第二种方式是<strong>尝试重新发送</strong>，直到接收方收到正确的信息。</li> </ul> <ol> <li>假如简单地使用<strong>尝试重新发送</strong>方法，需要哪些方式判断接收方已正确接收信息？</li> </ol> <ul> <li>接收方是否收到分组？</li> <li>接收方收到的分组是否与发送方发送的一样。</li> <li>对于两个问题问题， 可以向发送方发送<strong>确认[ACK]</strong>，但同样伴随着一些新的问题。</li> <li>如果 ACK 丢失了怎么办？ <ul> <li>重发就好了，但可能会导致接收方收到冗余数据，因此接收需要对这种情形做处理，这个问题可以用序列号解决，重复的序列号丢弃。</li> </ul> </li> <li>如果分组收到了，但里边有错怎么办？ <ul> <li>用额外的数据对错误的编码进行纠正。</li> <li>用校验和检测数据正确性，如果错误则不发送 ACK，等待重发。</li> </ul> </li> <li>发送方对一个 ACK 应该等待多长时间？ <ul> <li>即超时重传的时间，这取决于发送耗时+接收方处理耗时+ACK返程耗时，这很难估计，因为收到硬件设备的影响，所以只能通过预估。预估策略可以是统计然后算出均值，动态设置超时时间，但并非如此简单，因为有些样本是异常的，不能参与统计计算。总得来说时间预估是可行的，只是比较复杂，这里暂且不表，只提个大概。</li> </ul> </li> </ul> <ol> <li>目前为止，可以保证接收方收到正确的信息，但这是建立在分组是同步地、有序地去发送的前提下。这样效率不高，因为需要等待 ACK 顺利送达之后才能进行下一步，中间如果出现丢包或者时延过高，传输效率会大幅降低，如何解决这个问题？</li> </ol> <ul> <li>同步不行考虑并行，可以同时发送多个分组，但并行会增加通信的复杂度，带来以下问题： <ul> <li>3-1 什么时候发？</li> <li>3-2 发多少？</li> <li>3-3 每个分组在等待ack时，如何维持计时器？</li> <li>3-4 需要维持每个分组的备份以备重传</li> <li>3-5 接收方需要区分哪些分组已收到，哪些没有</li> <li>3-6 接收方还需要维护分组的次序</li> <li>3-7 如果接收方的接收速率比发送方慢怎么办？</li> </ul> </li> </ul> <ol> <li>如何解决并行分组带来的问题？</li> </ol> <ul> <li>为了解决问题 3-4、3-5、3-6 <ul> <li>首先，定义一个数组，数组的元素是每个分组，再定义一个长度N指代允许并行发送的分组大小。接下来分步骤： <ol> <li>初始状态下，下标0~N是允许并行发送的分组。（解决3-4）</li> <li>0~N的分组并行发送，然后出于等待ACK的状态下。</li> <li>假如0号分组收到ACK，则下标1~N+1为允许并行发送的分组，0号分组因为收到确认，可以从数组中移除了。</li> <li>任何新来的分组，都应塞在数组最后。</li> </ol> </li> <li>接收方同理，数组上分配着已接收、已确认、期待接收的分组。(解决3-5、3-6)</li> <li>此方法称为<strong>滑动窗口</strong>，由N个格子在数组上滑动可以看出来。然而N应该多大？(4-1)</li> </ul> </li> <li>为了解决问题 3-2、3-7 <ul> <li>既然发送方太快，那我们就让他慢一点嘛，让他的发送速度永远不超过某个速度即可。</li> <li>另一种方法是动态控制窗口N的大小，由接收方在ACK携带窗口大小的通告，这样能保护接收方。至于中间节点如路由器，则要依赖<strong>拥塞控制</strong>算法，这里暂且不表。</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="tech"/><category term="tcp"/><category term="computer-science"/><summary type="html"><![CDATA[Consider the design principles of TCP from the perspective of the problem.]]></summary></entry></feed>