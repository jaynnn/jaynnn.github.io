<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn, en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://jaynnn.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jaynnn.github.io/" rel="alternate" type="text/html" hreflang="cn, en"/><updated>2024-06-19T06:49:02+00:00</updated><id>https://jaynnn.github.io/feed.xml</id><title type="html">JaynAlpha</title><subtitle>enum JaynAlphaBlog{Rust, IndieGameDev, bevy} </subtitle><entry><title type="html">tcp的两点问题</title><link href="https://jaynnn.github.io/blog/2020/two-question-about-tcp/" rel="alternate" type="text/html" title="tcp的两点问题"/><published>2020-05-30T22:09:00+00:00</published><updated>2020-05-30T22:09:00+00:00</updated><id>https://jaynnn.github.io/blog/2020/two-question-about-tcp</id><content type="html" xml:base="https://jaynnn.github.io/blog/2020/two-question-about-tcp/"><![CDATA[<ol> <li>为什么是三次握手，而不是两次、四次？<br/> 要确保信息传输的完整性，我们需要保证数据具有同步性，tcp连接做的设计是保持初始序列号的同步，即A-&gt;B发送seq=j，B回复seq=j+1，这时候A就可以确定B已经同步了自己的序列号了；同理，B-&gt;A发送seq=k, A回复seq=k+1，这是双方就都确定信息已经同步。<br/> 那么问题就很清晰了，为什么不是四次？即</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. A(j)-&gt;B
    2. B(j+1)-&gt;A
    3. B(k)-&gt;A
    4. A(k+1)-&gt;B
</code></pre></div></div> <p>很明显，[2]、[3]可以合成一步，多余的事情不必做。为什么不是两次？即</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1. A(j) -&gt; B
    2. B(j+1 &amp; k) -&gt; A
</code></pre></div></div> <p>也很明显，B并不能确定A同步了自己的序列号。如果[2]在网络上丢失了，这时候就信誓旦旦建立连接，A可以确定B收到了自己的数据，但B并不能确定数据是否正确到达A。</p> <ol> <li>time_wait的作用<br/> time_wait是在主动关闭的一端接收到fin之后进入的状态，为什么需要这个状态呢？原因有两点。</li> </ol> <ul> <li>确保客户端的最终ACK能到达服务器。客户端在收到fin不维护状态信息，则会发送一个错误信息，然后被服务器认定为错误（喂你怎么不转状态，一点反应都没有，是不是崩了），那么服务器就没办法判定这个客户端是否已经关闭了连接（相当于上个问题的[4]没有确认），这时候客户端就需要重传ACK了，若没有TIME_WAIT阶段，客户端已经关闭了，那还怎么重传？</li> <li>保证新建立的连接收到的数据包都是新的。首先了解一个假设（事实）：MSL(最大分节生命期)，即数据包在网络上的存活时间不会不会超过MSL秒。当一个连接建立后，可能会发生重传的现象，即有些数据包在网络上乱串没有到达最终主机，但重发的数据包已经到达了目的主机且手都挥完。在最极限的状态下，乱串数据包还有MSL时间到达目的主机，乱串数据包的回包也有MSL时间回到源主机。这时候如果没有等待阶段，直接新建立了一个完全相同的ip和端口组的连接，旧数据包就会影响新连接的数据。因此需要一个TIME_WAIT阶段，且具有2MSL的时间让时间抹去数据的痕迹，让他们不会影响到新的连接。</li> </ul> <hr/> <ol> <li>为什么需要四次挥手？(2024/0618)<br/> 因为服务端需要先告知客户端自己收到了断开连接的请求，而自己的主动断开需要等到应用层完成断开连接所需要的操作之后再发出。也就是中间的两次信息传输无法合并了。</li> </ol>]]></content><author><name></name></author><category term="tech"/><category term="tcp"/><category term="computer-science"/><summary type="html"><![CDATA[two question about tcp.]]></summary></entry><entry><title type="html">从问题出发考虑TCP的设计原理</title><link href="https://jaynnn.github.io/blog/2020/tcp-design/" rel="alternate" type="text/html" title="从问题出发考虑TCP的设计原理"/><published>2020-05-30T22:09:00+00:00</published><updated>2020-05-30T22:09:00+00:00</updated><id>https://jaynnn.github.io/blog/2020/tcp-design</id><content type="html" xml:base="https://jaynnn.github.io/blog/2020/tcp-design/"><![CDATA[<ol> <li>信息通信里，不可避免信息量会<strong>有损</strong>，如何解决这个问题，保证信息传输是完整而正确的？ <ul> <li>第一种方式是<strong>差错校验码</strong>，通过添加冗余的比特，以恢复真实信息。</li> <li>第二种方式是<strong>尝试重新发送</strong>，直到接收方收到正确的信息。</li> </ul> </li> <li>假如简单地使用<strong>尝试重新发送</strong>方法，需要哪些方式判断接收方已正确接收信息？ <ul> <li>接收方是否收到分组？</li> <li>接收方收到的分组是否与发送方发送的一样。</li> <li>对于两个问题问题， 可以向发送方发送<strong>确认[ACK]</strong>，但同样伴随着一些新的问题。</li> <li>如果 ACK 丢失了怎么办？ <ul> <li>重发就好了，但可能会导致接收方收到冗余数据，因此接收需要对这种情形做处理，这个问题可以用序列号解决，重复的序列号丢弃。</li> </ul> </li> <li>如果分组收到了，但里边有错怎么办？ <ul> <li>用额外的数据对错误的编码进行纠正。</li> <li>用校验和检测数据正确性，如果错误则不发送 ACK，等待重发。</li> </ul> </li> <li>发送方对一个 ACK 应该等待多长时间？ <ul> <li>即超时重传的时间，这取决于发送耗时+接收方处理耗时+ACK返程耗时，这很难估计，因为收到硬件设备的影响，所以只能通过预估。预估策略可以是统计然后算出均值，动态设置超时时间，但并非如此简单，因为有些样本是异常的，不能参与统计计算。总得来说时间预估是可行的，只是比较复杂，这里暂且不表，只提个大概。</li> </ul> </li> </ul> </li> <li>目前为止，可以保证接收方收到正确的信息，但这是建立在分组是同步地、有序地去发送的前提下。这样效率不高，因为需要等待 ACK 顺利送达之后才能进行下一步，中间如果出现丢包或者时延过高，传输效率会大幅降低，如何解决这个问题？ <ul> <li>同步不行考虑并行，可以同时发送多个分组，但并行会增加通信的复杂度，带来以下问题： <ul> <li>3-1 什么时候发？</li> <li>3-2 发多少？</li> <li>3-3 每个分组在等待ack时，如何维持计时器？</li> <li>3-4 需要维持每个分组的备份以备重传</li> <li>3-5 接收方需要区分哪些分组已收到，哪些没有</li> <li>3-6 接收方还需要维护分组的次序</li> <li>3-7 如果接收方的接收速率比发送方慢怎么办？</li> </ul> </li> </ul> </li> <li>如何解决并行分组带来的问题？ <ul> <li>为了解决问题 3-4、3-5、3-6 <ul> <li>首先，定义一个数组，数组的元素是每个分组，再定义一个长度N指代允许并行发送的分组大小。接下来分步骤：</li> </ul> </li> </ul> <ol> <li>初始状态下，下标0~N是允许并行发送的分组。（解决3-4）</li> <li>0~N的分组并行发送，然后出于等待ACK的状态下。</li> <li>假如0号分组收到ACK，则下标1~N+1为允许并行发送的分组，0号分组因为收到确认，可以从数组中移除了。</li> <li>任何新来的分组，都应塞在数组最后。 - 接收方同理，数组上分配着已接收、已确认、期待接收的分组。(解决3-5、3-6) - 此方法称为<strong>滑动窗口</strong>，由N个格子在数组上滑动可以看出来。然而N应该多大？(4-1) <ul> <li>为了解决问题 3-2、3-7 <ul> <li>既然发送方太快，那我们就让他慢一点嘛，让他的发送速度永远不超过某个速度即可。</li> <li>另一种方法是动态控制窗口N的大小，由接收方在ACK携带窗口大小的通告，这样能保护接收方。至于中间节点如路由器，则要依赖<strong>拥塞控制</strong>算法，这里暂且不表。</li> </ul> </li> </ul> </li> </ol> </li> </ol>]]></content><author><name></name></author><category term="tech"/><category term="tcp"/><category term="computer-science"/><summary type="html"><![CDATA[Consider the design principles of TCP from the perspective of the problem.]]></summary></entry></feed>